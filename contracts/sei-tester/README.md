# Purpose

This package primarily serves as testing support for the sei-cosmwasm package.
It includes an example contract that can be used to test package behavior 
locally and can be used as a reference for implementation details to include 
sei-chain integration in your smart contracts.

## Examples

### Call an EVM contract from a CosmWasm contract

First we need deploy an EVM contract on the Sei chain. Let's use a simple counter contract and
foundry tooling to deploy it.

Install the [foundry tooling](https://book.getfoundry.sh/) by following this [installation guide](https://book.getfoundry.sh/getting-started/installation.html).


Create a new project following the [Creating New Project Guide](https://book.getfoundry.sh/projects/creating-a-new-project).

Once project is created, tweak the contract code to the following, by adding a `getCounter` function:

```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

contract Counter {
    uint256 public number;

    function setNumber(uint256 newNumber) public {
        number = newNumber;
    }

    function increment() public {
        number++;
    }

    function getCount() public view returns (uint256) {
        return number;
    }
}

```

And the test to the following:
```solidity
// SPDX-License-Identifier: UNLICENSED
pragma solidity ^0.8.13;

import {Test, console} from "forge-std/Test.sol";
import {Counter} from "../src/Counter.sol";

contract CounterTest is Test {
    Counter public counter;

    function setUp() public {
        counter = new Counter();
        counter.setNumber(0);
    }

    function test_Increment() public {
        counter.increment();
        assertEq(counter.number(), 1);
    }

    function testFuzz_SetNumber(uint256 x) public {
        counter.setNumber(x);
        assertEq(counter.number(), x);
    }

    function test_GetCount() public {
        uint256 initialCount = counter.getCount();
        counter.increment();
        assertEq(counter.getCount(), initialCount + 1);
    }
}
```
Run the tests with the following command:
```shell
forge test
```
If tests pass, deploy the contract to the Sei chain with the following command:
```shell
forge create --rpc-url $SEI_NODE_URI --mnemonic $MNEMONIC src/Counter.sol:Counter
```
Where `$SEI_NODE_URI` is the URI of the Sei node and `$MNEMONIC` is the mnemonic of the account that will deploy the 
contract.
If you run local Sei node the address will  be `http://localhost:8545`.
If deployment is successful, you will get the EVM contract address.
```shell
[â ’] Compiling...
No files changed, compilation skipped
Deployer: 0xAddress
Deployed to: 0xContractAddress
Transaction hash: 0xTransactionHash

```
Let's use the `cast` command to query the contract:
```shell
cast call $0X_CONTRACT_ADDRESS "getCount()(uint256)"
```
Where `$0X_CONTRACT_ADDRESS` is the address of the deployed contract that you take from `Deployed to` row in the output
of the previous command.
The command should return `0` as the initial value of the counter.

Now we can use the `cast` command to call the `increment` function:
```shell
cast send $0X_CONTRACT_ADDRESS "increment()" --mnemonic $MNEMONIC
```
If command is successful, you will get the transaction hash and other info back.

Now let's call the `getCount` function again and this case it should return `1`.

If that works, we can now deploy the CosmWasm contract that will call the EVM contract.

Follow the instructions in [this README](../../README.md)  to deploy the test contract.

Once the contract is deployed, we can query EVM contract from the CosmWasm contract.
Please note the contract address of the CosmWasm contract or export it as `$COSMWASM_CONTRACT_ADDRESS`.
Before we do that, we need to get the correct inputs.
To generate inputs, we can use the `seid` command line tool.

First we need to get the ABI of the EVM contract. It was generated by the foundry tooling and is usually located in the 
`out` folder. E.g. at path `out/Counter.sol/Counter.json`.

For our example the ABI looks like this:

```json
[{"type":"function","name":"getCount","inputs":[],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"increment","inputs":[],"outputs":[],"stateMutability":"nonpayable"},{"type":"function","name":"number","inputs":[],"outputs":[{"name":"","type":"uint256","internalType":"uint256"}],"stateMutability":"view"},{"type":"function","name":"setNumber","inputs":[{"name":"newNumber","type":"uint256","internalType":"uint256"}],"outputs":[],"stateMutability":"nonpayable"}]
```
For convenience, we can save the ABI to a file, e.g. `abi.json`.

Now let's generate the inputs for the `seid` command line tool.

```shell
seid q evm payload abi.json increment
```
That could produce result like `d09de08a`. This is hex encoded function input.
For our example though we need bash64 encoded bytes. So let's convert it:
```shell
echo -n 'd09de08a' | xxd -r -p | base64
```
This should produce result like `0J3gig==`

```shell
seid tx wasm execute  $COSMWASM_CONTRACT_ADDRESS '{"call_evm": {"value": "0", "to": "$0X_CONTRACT_ADDRESS", "data": "0J3gig==" }}' --from=admin --broadcast-mode=block --fees=200000usei --gas=3000000
```
This command will call the `increment` function of the EVM contract from the CosmWasm contract.
So now the counter should be `2`. Let's verify with the `cast` command first:
```shell
cast call $0X_CONTRACT_ADDRESS "getCount()(uint256)"
```
And now also with the `seid` command:
```shell
seid q evm payload out/abi.json getCount
```
```shell
echo -n 'a87d942c' | xxd -r -p | base64
```
```shell
seid q wasm contract-state smart $COSMWASM_CONTRACT_ADDRESS '{"static_call": {"from": "$SEI_ACCOUNT_ADDRESS", "to": "$0X_CONTRACT_ADDRESS", "data": "qH2ULA==" }}' 
```
The above command should return output like this:
```shell
data:
  encoded_data: AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI=
```
Let's decode it:
```shell
echo 'AAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAAI=' | base64 -D | od -t u1 -An -j 31
```
This should return `2` as well.